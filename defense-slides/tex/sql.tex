\section{Introduction and Related Work}
\frame{\sectionpage}


\begin{frame}[fragile]{SQL: Introduction}
    Given a SQL query, how is it executed?
    \begin{lstlisting}[language=SQL, caption= SQL query to execute.]
        SELECT MovieTitle
        FROM StarsIn
        WHERE StarName IN(
            SELECT name
            FROM MovieStar
            WHERE birthdate LIKE '%1960'
        );
    \end{lstlisting}
\end{frame}

\begin{frame}{SQL: Pipeline}
    \begin{figure}
        \centering
        \includegraphics[scale=0.25]{query_processor.png}\\
        \caption{The pipeline for query processing}
        \label{fig:query_processor}
    \end{figure}
\end{frame}

\begin{frame}{SQL: Parser}
    \begin{figure}
        \centering
        \includegraphics[scale=0.25]{parse_tree.png}\\
        \caption{An example of parse tree}
        \label{fig:prase_tree}
    \end{figure}
\end{frame}

\begin{frame}{SQL: Preprocessing}
    Sanity checking
    \begin{enumerate}
        \item Check relation uses
        \item Check and resolve attribute uses.
        \item Check types.
    \end{enumerate}
\end{frame}

\begin{frame}{SQL: Relational Algebra}
    \begin{figure}
        \centering
        \includegraphics[scale=0.25]{join_pushdown1.png}\\
        \caption{An example of join being optimized}
        \label{fig:j_1}
    \end{figure}
\end{frame}

\begin{frame}{SQL: Relational Algebra}
    \begin{figure}
        \centering
        \includegraphics[scale=0.25]{join_pushdown2.png}\\
        \caption{An example of Relational Algebra being used for optimization}
        \label{fig:j_2}
    \end{figure}
\end{frame}

\begin{frame}{SQL: Rewrite}
    Need to convert the query plan using Relational Algebra into a query plan which requires has lowest cost according to estimates.
\end{frame}

\begin{frame}{SQL: Cost: Estimation}
    \begin{enumerate}
        \item Give accurate estimates. No matter what method is used for executing query plans.
        \item Are easy to compute.
        \item Are logically consistent.
    \end{enumerate}
\end{frame}

\begin{frame}{SQL: Cost: Methods}
    \begin{enumerate}
        \item Histogram
        \item Heuristics
        \item Top-Down
        \item Bottom-up
        \item Dynamic Programming
        \item Branch-and-Bound
        \item Hill Climbing
        \item Selinger-Style Optimization
    \end{enumerate}
\end{frame}

\begin{frame}{SQL: Cost: Considerations}
    \begin{enumerate}
        \item An order and grouping for associative-and-commutative operations
        \item An algorithm for each operator
        \item Additional operators - scanning, sorting
        \item The way in which arguments are passed    
    \end{enumerate}
\end{frame}

\begin{frame}{SQL: Joins}
    \begin{enumerate}
        \item Algorithm Nested-loop join
        \item Algorithm Index join
        \item Order Dynamic Programming
        \item Order Greedy
    \end{enumerate}
\end{frame}

\begin{frame}{SQL: Physical Plan}
    \begin{enumerate}
        \item Selection, Index based
        \item Selection, Table Scan
        \item Join, One-pass join
        \item Join, Hash join
        \item Join, Index join
    \end{enumerate}
\end{frame}

\begin{frame}{Stream Query Optimization}
    Modifying queries by changing graph topology and/ or operators to get better performance, as measured by
    \begin{enumerate}
        \item Throughput
        \item Latency
        \item Resource Usage.
    \end{enumerate}
    While preserving semantice of the original query.
\end{frame}

\begin{frame}{Stream Graph}
    Queries on Data streams can be thought of as directed graphs,
    \begin{enumerate}
    \item Edges represent streams and nodes represent operators.
    \item Root  and  leaf nodes are called sources and sinks, respectively.
    \end{enumerate}
    Whereas for traditional Databases, we have parse trees.
\end{frame}

\begin{frame}{Possible Optimizations}
    \begin{itemize}
        \item Batching
        \item Placement
        \item State sharing
        \item Load Balancing
        \item Algorithm selection
        \item Load Shedding
        \item Fusion
        \item Operator Separation
        \item Operator Reordering
        \item Redundancy elimination
        \item Fission
    \end{itemize}
\end{frame}

\begin{frame}{Operator Reordering}
    A reordering operator moves more selective operators, which reduce the data volume upstream. This has the benefit of reducing the amount of data flowing into downstream compuration. Thus eliminatin unnecessary work. 
    We focus on finding the optimal method of executing associative opeators.
\end{frame}

\section{Research Question}
\frame{\sectionpage}

\begin{frame}{Research Question}
    \begin{center}
    Is it possible to apply deep reinforcement learning to find the optimal ordering of executing associative operations?
    \end{center}
\end{frame}



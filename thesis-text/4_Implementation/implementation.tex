\chapter{Implementation}
\label{chapter:implementation}
\thispagestyle{myheadings}

% set this to the location of the figures for this chapter. it may
% also want to be ../Figures/2_Body/ or something. make sure that
% it has a trailing directory separator (i.e., '/')!
\graphicspath{}
This chapter explores the steup required to conduct the experiments. The chapter is divided into data generation, query execution and lastly deep reinforcement learning for move prediction.

\section{Data Generation}
The data is generated using the walmart linear road found \cite{walmart_linearoad}

\begin{lstlisting}[language=bash]
java com.walmart.linearroad.generator.LinearGen [-o <output file>] [-x <number of xways>] [-m <dummy value to activate multi-threading>]
\end{lstlisting}

\subsection{Schema}
The above generated data can be interpretated as follows:-
\begin{center}
\begin{tabular}{ |c|c| } 
 \hline
  \multirow{5}{4em}{Column$1$} & Tells the type of query. \\  
            &	0: position report\\
			&	2: account balance request\\
			&	3: daily expenditure request\\
			&	4: travel time request	\\
 \hline
  Column$2$ & Timestamp position. \\  
 \hline
  Column$3$ & Vehicle identification number\\  
 \hline
  Column$4$ & Speed of the vehicle \\  
 \hline
  Column$5$ & Express way number \\  
 \hline
  Column$6$ & Lane ID $(0,...,4)$\\  
 \hline
  Column$7$ & Direction of movement($0=$East or $1=$West) \\  
 \hline
  Column$8$ & Segment ID $(0,...,99)$ \\
 \hline
  Column$9$ & Position of the vehicle. \\  
 \hline
  Column$10$ & Query identifier \\  
 \hline
  Column$11$ & Start Segment \\  
 \hline
  Column$12$ & End Segment \\  
 \hline
  Column$13$ & Day of the week \\  
 \hline
  Column$14$ & Minute of the day \\  
 \hline
  Column$15$ & Day in the past $10$ weeks \\  
 \hline
\end{tabular}
\end{center}

\section{Query Execution}
The idea was to combine different data streams into $1$, but given this data as input, it is already combined.\\
We implement $C++$ code for both the simpler query and the complex query in the previous section.
\subsection{Simpler Query}
The goal of implementing the simpler query was to get a sense of time required for executing the queries.\\
To start, a window size was fixed which determined the size/ number of entries to read and store at once, the window size was interpretted in two ways, either the number of entries to read or the time interval for which to read the entries. This value was passed to the read function everytime.
\begin{lstlisting}[language=C++]
FILE *pFile;
pFile = fopen (argv[1],"r");

int database[window_size][4];

std::vector<int> vect;
vect.clear();
std::vector<std::vector<int>> output;

auto start = std::chrono::high_resolution_clock::now();
while(!feof(pFile))
{
    //Take input everytime
    input_database(pFile, database, window_size);
    
    //executing the query
    format(database, output, vect, window_size);
    // 
    
    output.clear();
    vect.clear();
}
auto stop = std::chrono::high_resolution_clock::now(); 
auto duration = std::chrono::duration_cast<std::chrono::microseconds>(stop - start);
std::cout << duration.count() << std::endl;
fclose(pFile);
\end{lstlisting}
The input was taken by simply reading a file and storing the attribute values important to the query. 
\begin{lstlisting}[language=C++]
void input_database(FILE * pFile, int d[][4],int window_size)
{
    int i,j;
    for(i=0;i<window_size;i++)
    {
        fscanf (pFile, "%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i", &j,
        &j,&j,&d[i][0],&d[i][1],&j,&d[i][2],&d[i][3],&j,&j,&j,&j,&j,&j,&j);
        //printf ("%i,\n",database[i][0]);
    }
}
\end{lstlisting}
The next part where the actual query is executed, to execute the aggregate functions, first insert all the data into a vector of vectors, then sort vector using an ordering determined by the group by parameters. 
\begin{lstlisting}[language=C++]
for(i;i<window_size;i++)
{
    if(d[i][2]==0)
    {
        vect.push_back(d[i][1]);
        vect.push_back(d[i][2]);
        vect.push_back(d[i][3]);
        vect.push_back(d[i][0]);
        output.push_back(vect);
    }
    vect.clear();
}
std::sort(output.begin(),output.end(), my_sort);
\end{lstlisting}
Finally do the aggregation
\begin{lstlisting}[language=C++]
int count = 1;
std::sort(output.begin(),output.end(), my_sort);
//print_2dvector(output);

std::vector<std::vector<int>> op;
op.push_back(output[0]);
for(i=1;i<output.size();i++)
{
    //printf("%d %d\n",op.back()[3], count);
    if((output[i][0]==output[i-count][0])&&(output[i][1]==output[i-count][1])&&(output[i][2]==output[i-count][2]))
    {
        op.back()[3]=op.back()[3]+output[i][3];
        count++;
    }
    else
    {
        op.back()[3]=op.back()[3]/(count);
        op.push_back(output[i]);
        count = 1;
    }
    //printf("%d %d\n\n",op.back()[3], count);
}
op.back()[3]=op.back()[3]/count;
output.clear();
output=op;
op.clear();
\end{lstlisting}

\subsection{Complex Query}
For the complex query we also need to store data for our DRL model. We start by giving the general outline of the code. We first define the window size in similar way to the simple query and then loop over the Linear road data file.
\begin{lstlisting}[language=C++]
int window_size=10000;
FILE *pFile;
pFile = fopen (argv[1],"r");

std::ofstream op_file;
op_file.open("q3out.txt");

std::vector<std::vector<int>> database;
std::vector<std::vector<int>> curCarSeg;
std::vector<std::vector<int>> segAvgSpeed;
std::vector<std::vector<int>> segVol;

int temp;
while(!feof(pFile))
{
    
    input_database(pFile, database, window_size);
    read_times++;
    printf("read times is, %d\n", read_times);
    curcarseg(database, curCarSeg);
    temp=curCarSeg.size();
    printf("    CurCarSeg size is, %d\n", temp);
    segavgspeed(database,segAvgSpeed);
    temp=segAvgSpeed.size();
    printf("    SegAvgSpeed size is, %d\n", temp);
    segvol(curCarSeg,segVol);
    temp=segVol.size();
    printf("    SegVol size is, %d\n", temp);
    segtoll(segAvgSpeed,segVol,op_file);
    
    curCarSeg.clear();
    segAvgSpeed.clear();
    segVol.clear();
    database.clear();
}
fclose(pFile);
op_file.close();
\end{lstlisting}
In each loop we calculate the $CurCarSeg$, $SegAvgSpeed$ and $SegVol$ vectors.\\
For $CurCarSeg$, simply filter the cars for the last $5$ mins.\\
For $SegAvgSpeed$, we first filter the cars which were active in the last $5$ mins, then to apply aggregate function, initially sort them, then apply the function 
\begin{lstlisting}[language=C++]
    std::vector<std::vector<int>> temp;
    int cur_time=0;
    int i,j;
    std::vector<int> vect;
    vect.resize(4);
    for(i=0;i<d.size();i++)
    {
        if(cur_time<d[i][0])
        {
            cur_time=d[i][0];
        }
    }
    for(i=0;i<d.size();i++)
    {
        if(d[i][0]>cur_time-300)
        {
            vect[0]=d[i][2];
            vect[1]=d[i][3];
            vect[2]=d[i][4];
            vect[3]=d[i][6];
            temp.push_back(vect);
        }
    }
    //temp=()
    std::sort(temp.begin(),temp.end(), my_sort);
    //(express,dir,seg, average speed)
    int count = 1;
    s.push_back(temp[0]);
    for(i=1;i<temp.size();i++)
    {
        if(temp[i][0]==temp[i-1][0] and temp[i][1]==temp[i-1][1] and temp[i][2]==temp[i-1][2])
        {
            s.back()[3]=s.back()[3]+temp[i][3];
            count++;
        }
        else
        {
            s.back()[3]=s.back()[3]/(count);
            s.push_back(temp[i]);
            count = 1;
        }
    }
    s.back()[3]=s.back()[3]/count;
    temp.clear();
\end{lstlisting}
 
\begin{lstlisting}[language=C++]
\end{lstlisting}
 
\begin{lstlisting}[language=C++]
\end{lstlisting}
 
\section{Deep Reinforcement Learning}


\chapter{Stream Optimization}
\label{chapter:stream_optimization}
\thispagestyle{myheadings}

% set this to the location of the figures for this chapter. it may
% also want to be ../Figures/2_Body/ or something. make sure that
% it has a trailing directory separator (i.e., '/')!
\graphicspath{}

\section{Introduction}
\cite{stream_query_optimization}A stream is an ordered sequence of data items, which are values that can range from simple numbers to flat tuples to more  elaborate structured data that may be deeply nested and have variable size. Streams are conceptually infinite, in the sense that  as the streaming computation unfolds over time, the sequence of data items is unbounded in length.
\par Stream query optimization is the process of modifying a stream processing query, often by changing its graph topology and/or  operators, with the aim of achieving better performance (such as higher throughput, lower latency, or reduced resource usage), while preserving the semantics of the original query.
\par An optimization should be both safe and profitable. An optimization is safe if it can be applied to a stream query without   changing what it computes, as determined by the userâ€™s requirements. An optimization is profitable if it makes the stream query  faster, as measured by metrics that matter to the user, such as throughput, latency, or resource efficiency. There is a  substantial literature on different stream query optimizations, with different safety and profitability characteristics. This  entry lists the most common optimizations along with short descriptions.
\par Possible areas of optimization are, batch size, operation combining/ dividing, memory assignment, message passing, operation reordering, garbage collection. We focus mostly on operation reordering.

\section{Deep Reinforcement Learning}
Last chapter showcased how Deep reinforcement learning can help solve problems, by telling the best course of action. We are going to use those techniques to improve our operation reordering.

\section{Formalization}
To define a concrete problem statement, we will need to decide upon
\begin{itemize}
    \item The learning data, which will work as the input to our model, the data should be replicable so that model can be tested consistently.
    \item While more implementation based, the method to take input needs to be decided as well and maintained for consistancy reasons.
    \item After fixing the input data and method, for DSMS need to decide upon queries of sufficient complexity for the results to be interesting. 
    Only by having sufficiently complex queries will the query graph lead to interesting results.
    \item At this point need to combine the knowledge from chapter 2 regarding querying processing to come up with a prediction model, its execution, training and evaluation.
\end{itemize}

% 1. What is the stream query optimization? 
% We can have complex queries. Conctinous queries because it runs on top of the data stream. 
% They include join, selection, projection, user-defined functions, etc. 
% 
% 2. If we machine learning what is for us the training data. 
% We need to know about history of different runs of queries. 
% Query-1 can have different execution plans. {(P1, Cost1), (P2, Cost2), ... (Pn, Const_n)}. There is a min cost. 
% Our query does not match one-to-one to the past queries. How we can use parts of the past? 
% Query-1 comes with features of {f1, f2, ..., fn}, we have an optimized plan for this query. Things like graphs structures. 
% Query-future , you can extract features from it {f1, f2, ..., fn}

% Problem is almost a similarity matching problem. 


% 3. What are my inputs to the Machine learning Algorithms? What are my labesl? Are these coinous or labels (1/0), multi-lables. 

% Assumptions: Can stream change over time? Can the Sliding window change? 
% Why you can not do exact similarity match? Because we have never run that query before. 
% Why I can not do simple kNN? 



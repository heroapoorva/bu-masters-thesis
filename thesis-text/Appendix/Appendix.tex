\chapter{Extra code}
\label{appendix}
\thispagestyle{myheadings}

\begin{lstlisting}[language=C++, caption= code overview, label={lst:simple_query_overview}]
FILE *pFile;
int window_size=20000;
pFile = fopen (argv[1],"r");
int database[window_size][4];
std::vector<int> vect;
vect.clear();
std::vector<std::vector<int>> output;
auto start = std::chrono::high_resolution_clock::now();
while(!feof(pFile))
{
    input_database(pFile, database, window_size);
    execute(database, output, vect, window_size);
    output.clear();
    vect.clear();
}
auto stop = std::chrono::high_resolution_clock::now(); 
auto duration = std::chrono::duration_cast<std::chrono::microseconds>(stop - start);
std::cout << duration.count() << std::endl;
fclose(pFile);
\end{lstlisting}

\begin{lstlisting}[language=C++, caption= input function, label={lst:simple_query_input}]
void input_database(FILE * pFile, int d[][4],int window_size)
{
    int i,j;
    for(i=0;i<window_size;i++)
    {
        fscanf (pFile, "%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i,%i", &j,
        &j,&j,&d[i][0],&d[i][1],&j,&d[i][2],&d[i][3],&j,&j,&j,&j,&j,&j,&j);
    }
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption= groupby, label={lst:simple_query_groupby}]
for(i=0;i<window_size;i++)
{
    if(d[i][2]==0)
    {
        vect.push_back(d[i][1]);
        vect.push_back(d[i][2]);
        vect.push_back(d[i][3]);
        vect.push_back(d[i][0]);
        output.push_back(vect);
    }
    vect.clear();
}
std::sort(output.begin(),output.end(), my_sort);
\end{lstlisting}

\begin{lstlisting}[language=C++, caption= aggregation, label={lst:simple_query_aggregation}]
int count = 1;
std::sort(output.begin(),output.end(), my_sort);

std::vector<std::vector<int>> op;
op.push_back(output[0]);
for(i=1;i<output.size();i++)
{
    if((output[i][0]==output[i-count][0]))
    {
        if(output[i][1]==output[i-count][1])
        {
            if((output[i][2]==output[i-count][2]))
            {    
                op.back()[3]=op.back()[3]+output[i][3];
                count++;
            }
        }
    }
    else
    {
        op.back()[3]=op.back()[3]/(count);
        op.push_back(output[i]);
        count = 1;
    }
}
op.back()[3]=op.back()[3]/count;
output.clear();
output=op;
op.clear();
\end{lstlisting}

\begin{lstlisting}[language=C++, caption=complex query overview, label={lst:complex_query_overview}]
int window_size=10000;
FILE *pFile;
pFile = fopen (argv[1],"r");

std::ofstream op_file;
op_file.open("q3out.txt");

std::vector<std::vector<int>> database, curCarSeg, segAvgSpeed, segVol;

int temp;
while(!feof(pFile))
{
    
    input_database(pFile, database, window_size);
    read_times++;
    printf("read times is, %d\n", read_times);
    curcarseg(database, curCarSeg);
    temp=curCarSeg.size();
    printf("    CurCarSeg size is, %d\n", temp);
    segavgspeed(database,segAvgSpeed);
    temp=segAvgSpeed.size();
    printf("    SegAvgSpeed size is, %d\n", temp);
    segvol(curCarSeg,segVol);
    temp=segVol.size();
    printf("    SegVol size is, %d\n", temp);
    segtoll(segAvgSpeed,segVol,op_file);
    
    curCarSeg.clear();
    segAvgSpeed.clear();
    segVol.clear();
    database.clear();
}
fclose(pFile);
op_file.close();
\end{lstlisting}

\begin{lstlisting}[language=C++, caption= SegAvgSpeed, label={lst:SegAvgSpeed}]
    std::vector<std::vector<int>> temp;
    int cur_time=0;
    int i,j;
    std::vector<int> vect;
    vect.resize(4);
    for(i=0;i<d.size();i++)
    {
        if(cur_time<d[i][0])
        {
            cur_time=d[i][0];
        }
    }
    for(i=0;i<d.size();i++)
    {
        if(d[i][0]>cur_time-300)
        {
            vect[0]=d[i][2];
            vect[1]=d[i][3];
            vect[2]=d[i][4];
            vect[3]=d[i][6];
            temp.push_back(vect);
        }
    }
    //temp=()
    std::sort(temp.begin(),temp.end(), my_sort);
    //(express,dir,seg, average speed)
    int count = 1;
    s.push_back(temp[0]);
    for(i=1;i<temp.size();i++)
    {
        if(temp[i][0]==temp[i-1][0] and temp[i][1]==temp[i-1][1] and temp[i][2]==temp[i-1][2])
        {
            s.back()[3]=s.back()[3]+temp[i][3];
            count++;
        }
        else
        {
            s.back()[3]=s.back()[3]/(count);
            s.push_back(temp[i]);
            count = 1;
        }
    }
    s.back()[3]=s.back()[3]/count;
    temp.clear();
\end{lstlisting}
\begin{lstlisting}[language=C++, caption=SegVol, label={lst:SegVol}]
//d=(carid,exp,dir,seg)
std::sort(d.begin(),d.end(), my_sort2);
int i,j;
s.push_back(d[0]);
s.back()[0]=1;
for(i=1;i<d.size();i++)
{
    if(d[i][3]==d[i-1][3] and d[i][1]==d[i-1][1] and d[i][2]==d[i-1][2])
    {
        s.back()[0]++;
    }
    else
    {
        s.push_back(d[i]);
        s.back()[0]=1;
    }
}
\end{lstlisting}

\begin{lstlisting}[language=C++, caption=SegToll, label={lst:SegToll}]
int c1,r1,i,j,k,operation;
std::vector<float> entropy;
entropy=entropy_calc(s,v);
for(i=0;i<entropy.size();i++)
{
    op_file<<entropy[i]<<" ";
}
op_file<<std::endl;
op_file<<s.size()<<" "<<v.size()<<std::endl;
entropy.clear();
//v=(count of cars,exp,dir,seg)
//s=(express,dir,seg, average speed)
int times;
std::vector<int> order;
order.push_back(0);
order.push_back(1);
order.push_back(2);
order.push_back(3);

int max_times=24;
int num_op;
bool b;
for(times=0;times<max_times;times++)
{
    num_op=0;
    auto start = std::chrono::high_resolution_clock::now();
    for(i=0;i<s.size();i++)
    {
        for(j=0;j<v.size();j++)
        {
            b=false;
            for(k=0;k<4;k++)
            {
                operation=order[k];
                num_op++;
                switch(operation)
                {
                    case 0:
                        if(s[i][0]!=v[j][1])
                        {
                            b=true;
                        }
                    case 1:
                        if(s[i][1]!=v[j][2])
                        {
                            b=true;
                        }
                    case 2:
                        if(s[i][2]!=v[j][3])
                        {
                            b=true;
                        }
                    case 3:
                        if(s[i][3]>=40)
                        {
                            b=true;
                        }
                }
                if(b)
                {
                    break;
                }
            }
        }
    }
    auto stop = std::chrono::high_resolution_clock::now(); 
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(stop - start);
    
    for(i=0;i<4;i++)
    {
        op_file<<order[i]<<" ";
    }
    op_file<<std::endl<<duration.count()<<" "<<num_op<<std::endl;
    next_perm(order);
}
\end{lstlisting}

\begin{lstlisting}[language=Python, caption=DQN, label={lst:DQN}]
def reinforcement_learning(fin_train,save_loc,epoch_number):
    model = tf.keras.Sequential()
    model.add(tf.keras.layers.Dense(34,activation='relu'))
    model.add(tf.keras.layers.Dense(68,activation='relu'))
    model.add(tf.keras.layers.Dense(136,activation='relu'))
    model.add(tf.keras.layers.Dense(68,activation='relu'))
    model.add(tf.keras.layers.Dense(34,activation='relu'))
    model.add(tf.keras.layers.Dense(1))
    model.compile(optimizer='adam', loss='mse')


    times = int(epoch_number)
    for i in range(times):    
        cm=np.zeros(576).reshape(24,24)
        history=model.fit(x_tr, y2_tr, batch_size=100, epochs=1, callbacks=[cp_callback])
        ans=model.predict(x_te)
        seen=0
        correct=0
        for j in range(len(ans)):
            if(seen==0):
                m1=j
                m2=j
            if(ans[j]<ans[m1]):
                m1=j
            if(y2_te[j]<y2_te[m2]):
                m2=j
            #m1 is the prediction
            #m2 is the actual
            if(seen==23):
                seen=0
                cm[m1%24,m2%24]+=1
                if(m1==m2):
                    correct+=1
            else:
                seen+=1
        total=cm.sum()
        tp = np.asarray([cm[i,i] for i in range(24)])
        fp = cm.sum(axis=1) - tp
        fn = cm.sum(axis=0) - tp
        tn = np.asarray([total-(tp[i]+fp[i]+fn[i]) for i in range(24)]
        for i in range(24):
            try:
                a=(tp[i]+tn[i])/(tp[i]+tn[i]+fn[i]+fp[i])
                p=(tp[i])/(tp[i]+fp[i])
                r=(tp[i])/(tp[i]+fn[i])
                f=(2*p*r)/(p+r)
                print(a,p,r,f)
            except:
                print(i)   
        
        print(len(ans)/24,correct)
        del cm
\end{lstlisting}

